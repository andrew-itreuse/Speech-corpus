# multiprocessing test area

import multiprocessing as mp

from pathlib import Path
import csv
import os
import soundfile as sf
import resampy
import librosa
import wave
import random
import time
from pydub import AudioSegment


# more general function to resample
def deepspeech_resample(file_path: Path, destination_dir: Path):  # file_path and destination_dir should be Path objects
    # handles mp3 differently
    if file_path.suffix == ".mp3":
        try:
            new_audio = ffmpeg_mp3_to_wav(file_path, destination_dir)
            return new_audio
        except Exception as e:
            print(e)
            return False
    else:
        try:
            # resample wav
            x, s = librosa.load(file_path)

            y = resampy.resample(x, s, 16000)
            new_audio = destination_dir / (file_path.stem + ".wav")
            sf.write(new_audio, y, 16000, format="WAV")
            return new_audio
        except Exception as e:
            print(e)
            return False


def ffmpeg_mp3_to_wav(file: Path, dest_dir: Path):
    sound = AudioSegment.from_mp3(str(file))
    # write new wav file
    new_wav = dest_dir / (file.stem + ".wav")
    sound.export(str(new_wav), format="wav")
    # now read and resample it
    x, s = librosa.load(new_wav)
    res_audio = resampy.resample(x, s, 16000)
    sf.write(new_wav, res_audio, 16000, format="WAV")
    return new_wav


def mp_loop(sample):
    # we have successful multiprocessing (I think)
    # TODO: re-implement resampler here, and return the dict + file name
    line = sample[0]
    dest_dir = sample[1]
    audio_file_name = line[3]
    audio_file_parent = line[4]

    new_parent = dest_dir / os.path.relpath(line[4])  # makes path relative to this location
    if not new_parent.exists():
        new_parent.mkdir(parents=True)

    new_audio_wav = deepspeech_resample(Path(audio_file_parent)/audio_file_name, new_parent)
    if not new_audio_wav:
        # failed, go to next
        print("Resample failed")
        return False

    # get new wav audio properties to ensure compliance
    with wave.open(str(new_audio_wav), "rb") as wav:
        sample_rate = wav.getframerate()
        precision = wav.getsampwidth() * 8
        channels = wav.getnchannels()
    if not (sample_rate == 16000 and precision == 16 and channels == 1):
        print("Resulting file wrong")
        print(str(sample_rate) + ", " + str(precision) + ", " + str(channels))
        return False


    # return dict and file name
    data_dict = {
        "database": line[0],
        "source": line[1],
        "format": line[2],
        "audio_file_name": new_audio_wav.name,
        "audio_path": new_audio_wav.parent,
        "transcript": line[5],
        "aligned": line[6],
        "sampling": sample_rate,
        "recording_device": line[8],
        "bitrate": sample_rate * precision,
        "channels": channels,
        "precision": precision,
        "encoding": line[12],
        "date": line[13],
        "age": line[14],
        "gender": line[15],
        "accent": line[16],
        "country": line[17],
        "region": line[18],
        "user_name": line[19]
    }
    return [data_dict, new_audio_wav]


def downsample_from_csv(source: Path, dest: Path, dest_dir: Path):
    # check existence of the files
    if not source.exists():
        print(source.name + " not found")
        exit()
    if dest.exists():
        # conditionally remove old downsample csv
        print("Target: " + dest.name + " already exists, do you wish to remove it?")
        if input("y/n: ") == "y":
            os.remove(dest)
        else:
            print("Cancelling")
            exit()
    csv_dest = open(dest, "x", newline="")
    csv_writer = csv.writer(csv_dest, delimiter=",")
    # get total length of csv
    #with open(source) as f:
    #    reader = csv.reader(f, delimiter=",")
    #     row_count = sum(1 for row in reader) - 1
    row_num = 1  # track progress
    # iterate through csv
    with open(source) as c:
        csv_reader = csv.reader(c, delimiter=",")
        # write header of old csv to new
        csv_writer.writerow(next(csv_reader))

        # read csv contents to an array
        samples = []
        for row in csv_reader:
            # create pair [row, dest_dir] to be used in the function
            # really hacky way of doing it
            samples.append([row, dest_dir])
        row_count = len(samples) - 1
        # TODO: multiprocessing!
        pool = mp.Pool(mp.cpu_count())  # for server, 2

        # files will be generated by the processes, but the csv will only be writen to at the end
        # not great, but eliminates write conflicts
        for i, processed in enumerate(pool.imap_unordered(mp_loop, samples), start=1):
            # i is the job number
            # will need to get the audio file name from the function
            # processed = [data_dict, wav_name]
            if processed:
                data_dict = processed[0]
                csv_writer.writerow(data_dict.values())
                new_audio_wav = processed[1]
                with open(log_file, "a") as f:
                    f.write("Resample completed: " + new_audio_wav.name + " (" + str(i) + " / " + str(row_count) + ")\n")
                print("Resample completed: " + new_audio_wav.name + " (" + str(i) + " / " + str(row_count) + ")")
            else:
                # something went wrong
                with open(error_file, "a") as f:
                    f.write("Error resampling: " + new_audio_wav.name + "\n")
        # print(i)
        # print(processed)


# set csv file to read and write to, and dir to place new audio in
# these should be customised based on the dataset being used

# log to files
log_file = "log.txt"
with open(log_file, "w") as f:
    f.write("Progress log:\n")
error_file = "error.txt"
with open(error_file, "w") as f:
    f.write("Conversion errors:\n")
audio_csv = Path("output.csv")
dest_csv = Path("/mnt/big-drive-3000-gp3/data/SimpleVoiceResample/16kHz_output.csv")
target_dir = Path("/mnt/big-drive-3000-gp3/data/SimpleVoiceResample/16kHz")

downsample_from_csv(audio_csv, dest_csv, target_dir)

#deepspeech_resample(Path("32242.mp3"), Path("new_audio"))
